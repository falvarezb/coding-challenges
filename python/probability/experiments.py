from random import choices, sample
from itertools import product
import numpy as np
from count import enumerate_permutations_with_repetition, count_combinations_without_repetition, count_permutations_without_repetition, count_permutations_with_repetition


def dice_roll(num_trials, wanted_result):
    dice = range(1, 7)
    return choices(dice, k=num_trials).count(wanted_result)/num_trials


def two_dice_roll(num_trials, wanted_result):
    """
    Example
    -------

    What's the probability of getting 7 when rolling two dice (frequentist approach)
    """
    dice = range(1, 7)
    return list(np.array(choices(dice, k=num_trials)) + np.array(choices(dice, k=num_trials))).count(wanted_result)/num_trials


def two_dice_roll_classical(wanted_result):
    """
    Laplace approach
    """
    dice = range(1, 7)
    two_dice = enumerate_permutations_with_repetition(dice, 2)
    num_total_cases = len(list(two_dice))
    num_favourable_cases = list(map(lambda x: x[0] + x[1], two_dice)).count(wanted_result)

    return num_favourable_cases / num_total_cases


def balls_draw(white, black, drawn, white_wanted):
    """
    Example
    -------

    If 3 balls are “randomly drawn” from a bowl containing 6 white and 5 black balls, 
    what is the probability that one of the balls is white and the other two black?

    Frequentist approach
    """

    if(white_wanted > drawn):
        raise Exception("illegal argument, 'white_wanted' must be less or equal to 'drawn'")

    def aux(num_trials):
        bag = ['W'] * white + ['B'] * black

        def trial():
            return sample(bag, k=drawn).count('W') == white_wanted

        return sum(trial() for j in range(0, num_trials)) / num_trials

    return aux


def balls_draw_classical(white, black, drawn, white_wanted):
    """
    Laplace approach
    """
    if white_wanted > drawn:
        raise Exception("illegal argument, 'white_wanted' must be less or equal to 'drawn'")

    return count_combinations_without_repetition(white, white_wanted) * count_combinations_without_repetition(black, drawn - white_wanted) / count_combinations_without_repetition(white + black, drawn)


def married_couples(num_couples, num_trials):
    """
    Example
    -------

    Probability that 10 married couples are seated at random at a round table, then no wife sits next to her husband (frequentist approach)
    """

    def flatten(z):
        return [x for y in z for x in y]

    participants = flatten([[j*10, j*10 + 1] for j in range(num_couples)])

    def identify_couples_seated_together(participants):
        for j in range(len(participants) - 1):
            if abs(participants[j] - participants[j + 1]) == 1:
                return True

        return abs(participants[len(participants) - 1] - participants[0]) == 1

    def trial(participants):
        return identify_couples_seated_together(sample(participants, k=len(participants)))

    return 1 - sum(trial(participants) for j in range(0, num_trials)) / num_trials


def married_couples_theoretical(num_couples):
    """

    Probability that 10 married couples are seated at random at a round table, then no wife sits next to her husband.

    Steps:
    1. calculate probability that any of husbands sits next to his wife
    2. given that these events are not mutually exclusive (a couple sitting together does not prevent another one of sitting together),
    we need to use the inclusion-exclusion identity
    3. finally the wanted probability is the difference up to 1

    Note: brute-force approach consisting of enumerating all (2*10-1)! permutations and checking if any couple is sit together
    is not feasible as 19! = 121645100408832000 (that's why inclusion-exclusion identity is used).

    Interestingly enough, as it is proved by the test "test_married_couples" in "experiments_test.py", the frequentist approach
    can produce the right answer with just 100000 (10^5) trials, that is far less than all the combinations available 19! (roughly 10^17).

    What's more, as it is indicated on https://docs.python.org/3/library/random.html, the total number of permutations
    of a sequence can quickly grow larger than the period of most random number generators.
    This implies that most permutations of a long sequence can never be generated by a random generator.

    """

    def probM(n, m):
        """
        Probability that, given n couples A1, A2, ... , An, then the couples A1, A2, ... , Am (m <= n) sit together
        """

        num_arrangements_couples_sit_together = 2**m * count_permutations_without_repetition(2*n-m-1, 2*n-m-1)
        total_num_arrangements = count_permutations_without_repetition(2*n-1, 2*n-1)

        return num_arrangements_couples_sit_together/total_num_arrangements

    # inclusion-exclusion identity
    prob = 0
    for r in range(1, 10):
        prob += (-1)**(r+1) * count_combinations_without_repetition(num_couples, r) * probM(num_couples, r)

    return 1 - prob


def probM_generalized(n, m, k):
    """
    Probability that, given n groups A1, A2, ... , An, of k people each, then the couples A1, A2, ... , Am (m <= n) sit together
    """

    num_arrangements_members_same_group_sit_together = count_permutations_without_repetition(k, k)**m * count_permutations_without_repetition(k*n-m-1, k*n-m-1)
    total_num_arrangements = count_permutations_without_repetition(k*n-1, k*n-1)

    return num_arrangements_members_same_group_sit_together/total_num_arrangements


def groups_combination_classical(group1, group2, num_elem1, num_elem2, repetition):
    """
    Example
    -------

    What is the probability of getting a sequence of six digits where the number of even digits is equal to the number of odd digits?
    Laplace approach

    In this case:
    group1 = [0,2,4,6,8]
    group2 = [1,3,5,7,9]

    num_elem1 = 3
    num_elem2 = 3

    When repetition = True
    ----------------------

    (6 3) * 5^3 * 5^3 / 10^6

    Explanation: 
    1. consider all groups of 3 slots: (6 3)
    2. for each group, consider all permutation of 3 elements of group 1 that occupy the 3 slots: 5^3
    3. for each of the above permutations, consider all permutations of 3 elements of group 2 that occupy the remaining 6-3=3 slots: 5^3
    4. finally, the total number of permutations with repetition of 3+3 elements out of 5+5 is: 10^6


    When repetiton = False
    ----------------------

    (5 3) * (5 3) * 6! / (10*9*8*7*6*5)

    Explanation:
    1. consider all groups of 3 elements of group 1: (5 3)
    2. for each of th above groups, consider all groups of 3 elements of group 2: (5 3)
    3. for each of the above combinations of groups, consider all possible permutations: (3+3)!
    4. finally, the total number of permutations without repetition of 3+3 elements out of 5+5 is: 10*9*8*7*6*5

    """

    if repetition:
        return count_combinations_without_repetition(num_elem1 + num_elem2, num_elem1) * count_permutations_with_repetition(len(group1), num_elem1) * count_permutations_with_repetition(len(group2), num_elem2) / count_permutations_with_repetition(10, 6)
    return count_combinations_without_repetition(len(group1), num_elem1) * count_combinations_without_repetition(len(group2), num_elem2) * count_permutations_without_repetition(num_elem1 + num_elem2, num_elem1 + num_elem2) / count_permutations_without_repetition(10, 6)
    

def groups_combination_frequentist(group1, group2, num_elem1, num_elem2, repetition):
    """
    Frequentist approach
    """

    population = group1 + group2
    sample_size = num_elem1 + num_elem2

    def trial():
        my_sample = []
        if repetition:
            my_sample = choices(population, k=sample_size)
        else:
            my_sample = sample(population, k=sample_size)
        return sum([j in group1 for j in my_sample]) == num_elem1

    def aux(num_trials):
        return sum(trial() for j in range(0, num_trials)) / num_trials

    return aux
